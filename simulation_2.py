# -*- coding: utf-8 -*-
"""Simulation 2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BstNNXQ8VSDCBUm4YyzsJmbbveEeKq3G
"""

'''this simulation includes an eavesdropper who collapses the function'''

import numpy as np
from hashlib import sha256

# Function to create a superposition state
def create_superposition_state():
    # |0> state
    state_0 = np.array([[1], [0]])
    # |1> state
    state_1 = np.array([[0], [1]])
    # Hadamard operation
    H = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]])
    # Apply Hadamard to |0> state
    superposition_state = H @ state_0
    return superposition_state

# Function to create an entangled state
def create_entangled_state():
    # |00> state
    state_00 = np.array([[1], [0], [0], [0]])
    # |11> state
    state_11 = np.array([[0], [0], [0], [1]])
    # Bell state (|00> + |11>)/sqrt(2)
    entangled_state = (1/np.sqrt(2)) * (state_00 + state_11)
    return entangled_state

# Function to simulate eavesdropping
def simulate_eavsdropping(state, error_rate = 0.005):
    # Measurement operator for |0><0|
    M_0 = np.array([[1, 0], [0, 0]])
    # Measurement operator for |1><1|
    M_1 = np.array([[0, 1], [0, 0]])
    # Apply measurement operators
    prob_0 = (state.conj().T @ M_0 @ state).item()
    prob_1 = (state.conj().T @ M_1 @ state).item()
    # Collapse state based on measurement outcome
    if np.random.rand() < prob_0:
        collapsed_state = M_0 @ state / np.sqrt(prob_0)
        measurement = 0
    else:
        collapsed_state = M_1 @ state / np.sqrt(prob_1)
        measurement = 1

     # Introduce a measurement error with a small probability
    if np.random.rand() < error_rate:
        measurement = 1 - measurement  # Flip the measurement outcome

    return collapsed_state, measurement

# Superposition example
superposition_state = create_superposition_state()
print("Superposition State:")
print(superposition_state)

# Entanglement example
entangled_state = create_entangled_state()
print("\nEntangled State (Bell State):")
print(entangled_state)

# Eavesdropping example
collapsed_state, measurement = simulate_eavesdropping(superposition_state)
print("\nEavesdropping on Superposition State:")
print(f"Measurement Outcome: {measurement}")
print("Collapsed State:")
print(collapsed_state)




# Function to simulate a complete BB84 protocol
def simulate_bb84_protocol(n, error_rate = 0.05):
    global alice_bits, bob_results
    # Step 1: Alice prepares qubits
    alice_bits = np.random.randint(2, size=n)
    alice_bases = np.random.choice(['X', 'Z'], size=n)
    alice_qubits = []
    for bit, basis in zip(alice_bits, alice_bases):
        if bit == 1:
            qubit = np.array([[0], [1]])
        else:
            qubit = np.array([[1], [0]])
        if basis == 'X':
            H = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]])
            qubit = H @ qubit
        alice_qubits.append(qubit)

    print("\nAlice's bits: ", alice_bits)
    print("Length of Alice's key: ", str(len(alice_bits)))

    # Step 2: Bob measures qubits
    bob_bases = np.random.choice(['X', 'Z'], size=n)
    bob_results = []
    for qubit, basis in zip(alice_qubits, bob_bases):
        if basis == 'X':
            H = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]])
            qubit = H @ qubit
        collapsed_state, measurement = second_measurement(qubit, error_rate)
        bob_results.append(measurement)

    print("\nBob's results: ", bob_results)
    print("Length of Bob's key: ", str(len(bob_results)))

    # Step 3: Alice and Bob share their bases
    matching_bases = alice_bases == bob_bases
    key = []
    alice_filtered = []
    bob_filtered = []
    for i in range(n):
        if matching_bases[i]:
            key.append(alice_bits[i])
            alice_filtered.append(alice_bits[i])
            bob_filtered.append(bob_results[i])
    error_count = np.sum(np.array(alice_filtered) != np.array(bob_filtered))
    error_rate_actual = error_count / len(alice_filtered) if len(alice_filtered) > 0 else 0


    return key, error_rate_actual

# Simulate the BB84 protocol
n = 256  # Number of qubits
key, error_rate_actual = simulate_bb84_protocol(n, error_rate= 0.05)




print("\nSimulated BB84 Key:")
print(key)
print("\nFinal Key:")
print(key)
print("shared key: " + str(len(key)) + " out of " + str(n))
print(f"Error rate: {error_rate_actual:.2%}")