# -*- coding: utf-8 -*-
"""Simulation 3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O2kBQcpF8EXURzN2pVz69GZfIEEQeaP7
"""

'''This displays the code needed for a Low-density parity-check code'''
# Parameters for LDPC

n = 256  # Length of the encoded message
dv = 3   # Number of 1s per column in H matrix
dc = 4   # Number of 1s per row in H matrix
snr = 10  # Signal-to-noise ratio for the simulation
error_rate = 0.005  # Error rate in the channel

# Generate an LDPC code
H, G = make_ldpc(n, dv, dc, systematic=True, sparse=True)

# Information bits (Alice's bits)
k = G.shape[1]  # Length of the information bits
alice_bits = np.random.randint(2, size=k)
encoded_bits = encode(G, alice_bits, snr)

# Simulate transmission with noise (errors)
noisy_encoded_bits = encoded_bits.copy()
noisy_encoded_bits = np.array(noisy_encoded_bits > 0, dtype=int) # Convert the encoded bits to integers

#noise
for i in range(len(noisy_encoded_bits)):
    if np.random.rand() < error_rate:
        noisy_encoded_bits[i] ^= 1  # Flip the bit with a probability equal to error_rate

# Step 2: Bob decodes the received noisy encoded bits
decoded_bits = decode(H, noisy_encoded_bits, snr)

# Retrieve the original message
final_key = get_message(G, decoded_bits)

# Calculate the actual error rate
error_count = np.sum(alice_bits != final_key[:k])  # Only consider the first k bits
error_rate_actual = error_count / k

print("\nAlice's Original Key:")
print(alice_bits)
print("\nBob's Decoded Key:")
print(final_key[:k])
print(f"\nActual Error Rate: {error_rate_actual:.2%}")